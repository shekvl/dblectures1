<html>
<head>
<meta content="text/html; charset=windows-1251" http-equiv="Content-Type">
<link rel="stylesheet" type="text/css" href="../styles/Lectures.css">
<title>B-Trees</title>
</head>
<body>
<p><a href="javascript:window.close()">Закрыть</a>
<p>Дополнительный материал к теме "Индексы" 
<p><b>А. B-деревья</b> 
<p>B-деревья - это динамические структуры данных, которые позволяют производить 
поиск с гарантированной эффективностью. 
<p>B-деревом порядка n называется дерево, обладающее следующими свойствами: 
<ol>
<li> каждый узел (он еще называется страницей) имеет не более n сыновей </li>
<li> каждый узел, кроме корня и листьев, имеет не менее n/2 сыновей. </li>
<li> корень, если он не лист, имеет не менее 2 сыновей.</li>
<li> все листья расположены на одном уровне и не содержат информации</li>
<li> нелистовой узел с m сыновьями содержит m-1 ключей.<br>
</li>
</ol>
<p>Вот пример B-дерева порядка 5: 
<p><img src="btree1.gif" width="544" height="112"> 
<p> Для дальнейшего рассмотрения будем предполагать, что страница B-дерева имеет 
следующий вид : 
<p>
<img src="btreeleaf.gif" width="324" height="91">
<p> Здесь k - ключи, а p - указатели на потомков.</p>
<p><b>А.1. Поиск в B-дереве</b></p>
<p> Пусть имеется некоторая текущая страница и задан некоторый аргумент поиска 
x. На первом шаге последовательным или бинарным поиском осуществляется поиск значения 
x среди ключей k1...km. Если элемент найден, то поиск прекращается. Иначе возможны 
3 случая:</p>
<ol>
<li> k[i] &lt; x &lt; k[i+1] для 1&lt;=i&lt;=m. Поиск продолжается на странице, 
на которую указывает p[i].</li>
<li> k[m]&lt;x. Поиск продолжается на странице, на которую указывает p[m].</li>
<li> x&lt;k[1]. Поиск продолжается на странице, на которую указывает p[0].<br>
</li>
</ol>
<p>Если нужный указатель p нулевой, то такого ключа в дереве нет.</p>
<p><b>А.2. Добавление нового элемента в B-дерево</b></p>
<p> Если нужно вставить элемент в B-дерево порядка n, его вставляют в страницу 
самого нижнего уровня между ближайшим большим и ближайшим меньшим ключами. Если 
страница теперь содержит n ключей (больше максимально допустимого (n-1)), ее расщепляют 
на две страницы. 
<p>Для этого выбирают средний элемент среди всех ключей страницы : K[n/2]. Первый 
узел содержит все элементы, которые левее среднего, второй - все элементы, которые 
правее среднего. Сам K[n/2] вставляется на подходящее место в узел - отец. Эта 
вставка, в свою очередь, может привести к расщеплению узла - отца. Если нужно 
расщепить корневой узел, то просто создают новый корень и помещают в него единственный 
ключ K[n/2], в этом случае дерево становится на единицу выше.
<p> Для примера вставим в дерево элемент с ключом 25 . На первом шаге мы определяем, 
что его нужно вставить в правый узел. Но при этом мы обнаружим, что в нем будет 
5 элементов, а может быть не больше 4: 
<p><img src="btreeleaf2.gif" width="209" height="31">
<p>Нам необходимо расщепить этот узел и поднять средний элемент на уровень выше. 
Средний элемент - третий элемент (40) - он будет включен в узел верхнего уровня. 
<p>В первом узле будут элементы 20 и 25 , а во втором 50 и 70. Наше дерево примет 
вид: 
<p><img src="btree2.gif" width="585" height="115"> 
<p><b><br>
А.3. Удаление элемента из B-дерева</b> 
<p> При исключении элемента из B-дерева можно выделить 2 случая:</p>
<ol>
<li> исключаемый элемент находится на странице нижнего уровня. В этом случае на 
первом шаге он удаляется из страницы.</li>
<li> элемент находится на странице более высокого уровня. В этом случае его нужно 
заменить ближайшим меньшим или ближайшим большим элементом. </li>
</ol>
<p>Предположим, что у нас необходимо удалить элемент с ключом k[i] и мы хотим 
заменить его ближайшим меньшим элементом. Для поиска такого элемента необходимо 
сначала взять страницу, на которую указывает p[i-1]. После этого необходимо спуститься 
сверху вниз до страницы нижнего уровня P, переходя каждый раз на страницу, на 
которую указывает cамый правый указатель p[m] каждой страницы, заменить исключаемый 
элемент на самый правый элемент P и уменьшить размер P на 1.</p>
<p>После первого шага число элементов в странице может оказаться меньше минимально 
допустимого (n/2). В этом случае могут быть два варианта (мы рассматриваем наряду 
с P ее соседнюю страницу Q):</p>
<ol>
<li> число элементов в Q &gt; n/2. В этом случае элементы P и Q поровну распределяются 
на обе страницы - происходит т.н. балансировка страниц.</li>
<li> число элементов в Q = n/2. В этом случае P и Q сливаются в одну, добавляется 
средний элемент из родительской для P и Q страницы, а потом уничтожается страница 
Q. Если родительская страница станет меньше допустимой, то для нее нужно тоже 
сделать балансировку или слияние и т.д.</li>
</ol>
<p>Если корень сократится до нулевого размера, то он удаляется и тем самым высота 
B-дерева уменьшается.</p>
<p>B-деревья широко применяются при построении индексов в системах управления 
базами данных. В Oracle для обычных индексов листья содержат ROWID соответствующих 
строк, а в таблицах, основанных на индексах - непосредственно данные.</p>
<p class=copyright>© 1994-2001 Шеховцов В.А.
<p><a href="javascript:window.close()">Закрыть</a>
</body>
</html>
